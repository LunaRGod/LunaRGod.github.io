<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="月" href="https://lunargod.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="月" href="https://lunargod.github.io/atom.xml"><link rel="alternate" type="application/json" title="月" href="https://lunargod.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="java,git,springcloud"><link rel="canonical" href="https://lunargod.github.io/2024/05/10/Collection%E5%8D%95%E5%88%97%E9%9B%86%E5%90%88ListSet/"><title>Collection单列集合ListSet - Java | LunaRGFod = 月 = HelloWord</title><meta name="generator" content="Hexo 7.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">Collection单列集合ListSet</h1><div class="meta"><span class="item" title="创建时间：2024-05-10 22:09:49"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2024-05-10T22:09:49+08:00">2024-05-10</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>15k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>13 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">LunaRGFod</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://pic.imgdb.cn/item/67371d1fd29ded1a8c8cabbe.jpg"></li><li class="item" data-background-image="https://pic.imgdb.cn/item/673a9b7ad29ded1a8c291ec8.png"></li><li class="item" data-background-image="https://pic.imgdb.cn/item/67371c24d29ded1a8c8b65eb.jpg"></li><li class="item" data-background-image="https://pic.imgdb.cn/item/673bf185d29ded1a8c3262db.png"></li><li class="item" data-background-image="https://pic.imgdb.cn/item/67384617d29ded1a8c7501d9.png"></li><li class="item" data-background-image="https://pic.imgdb.cn/item/673a0952d29ded1a8cd335b7.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/Java/" itemprop="item" rel="index" title="分类于 Java"><span itemprop="name">Java</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://lunargod.github.io/2024/05/10/Collection%E5%8D%95%E5%88%97%E9%9B%86%E5%90%88ListSet/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="月"><meta itemprop="description" content="HelloWord, 你越安静 你听到的就越多"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="月"></span><div class="body md" itemprop="articleBody"><p><img data-src="https://pic.imgdb.cn/item/673dcfe2d29ded1a8cfd5af1.jpg" alt></p><h2 id="集合概念"><a class="anchor" href="#集合概念">#</a> 集合概念</h2><p>集合是一种特殊类，这些类可以存储任意类对象，并且长度可变，<strong>这些集合类都位于 java.util 中，使用的话必须导包</strong></p><p>按照存储结构可以分为两大类 单列集合 <code>Collection</code> 双列集合 <code>Map</code> 两种 区别如下</p><p><code>Collection</code> 单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的的子接口， <code>List Set</code></p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List  接口 特点是元素有序可重复 它的实现类有   ArrayList  LinkedList </span><br><span class="line"></span><br><span class="line"> Set  接口 特点是元素无序且不可重复它的实现类有 HashSet  TreeSet</span><br></pre></td></tr></table></figure><p></p><p><code>Map</code> 双列集合类的根接口，用于存储具有 键 (Key) 值 (Value) 隐射关系的元素，<strong> 每个元素都包 含一对键值</strong>，其中键值不可重复且每个键 最多只能映射到到一个值，在使用 Map 集合时 可以通过指定的 <code>Key</code> 找到对应的 <code>Value</code> , 通一个人的学号找到学生的名字一样<strong>没有爸爸接口，只要爷爷接口 Mpa 实现类有 HashMap TreeMap</strong></p><h2 id="collection-单列集合根接口"><a class="anchor" href="#collection-单列集合根接口">#</a> Collection 单列集合根接口</h2><p>单列集合的父接口，它定义了单例集合 ( <code>List Set</code> ) 通用的一些方法，这样方法可用于操作所有的单列集合，，在开发中，往往很少直接使用 Collcetion 接口进行开发基本上都是使用其子接口，子接口主要有 <code>List、Set、Queue和 SortedSeto</code></p><p><strong>常用 API</strong></p><p><img data-src="/2024/05/10/Collection%E5%8D%95%E5%88%97%E9%9B%86%E5%90%88ListSet/image_UkOqQ2yXmD.png"></p><h2 id="list接口"><a class="anchor" href="#list接口">#</a> List 接口</h2><p><code>List</code> 接口继承父接口 <code>Collection</code> 接口，是单列集合的一个重要分支，它允许出现重复的元素，所有元素都是以一种线性的方式存储的，通过索引访问 List</p><p>集合中的指定元素，它的特点是有序 ** 即元素 存入和取出的 顺序一致 **</p><p><code>List</code> 集合常用方法，上方父接口 <code>Collection</code> 方法同样可以继承使用</p><p>List 的所有实现类都可以通过调用这些方法操作集合元素</p><table><thead><tr><th>方法声明</th><th>功能描述</th></tr></thead><tbody><tr><td>void add ( int index, Object element )</td><td>将元素 element 插入在 List 集合的 index 处</td></tr><tr><td>boolean addAll ( int index, Collection c )</td><td>将集合所包含的所有元素插入到 List 集合的 index 处</td></tr><tr><td>Object get ( int index )</td><td>返回集合索引 inde 处的元素</td></tr><tr><td>Object remove ( int index )</td><td>删除集合索引 inde 处的元素</td></tr><tr><td>Object set ( int index, Object element</td><td>将集合索引 indx 处 元素替换成 element 对象，并将替换后的元素返回</td></tr><tr><td>int indexOf ( Object o )</td><td>返回对象 o 在 List 集合中出现的位置索引</td></tr><tr><td>int lastlndexOf ( Object o )</td><td>返回对象 o 在 List 集合中最后一次出现的位置索引</td></tr><tr><td>List subList ( int fromlndex, int tolndex )</td><td>返回从索引 fromindex (包括) 到 toindex (不包括) 处所有元素组成的子集合</td></tr></tbody></table><h3 id="arraylist实现类-查询-有序可重复"><a class="anchor" href="#arraylist实现类-查询-有序可重复">#</a> ArrayList 实现类 查询 有序可重复</h3><p><code>ArrayList</code> 是 <code>List</code> 接口的一个实现类，它是程序中一种常见的集合，在 ArrayList 内部封装了一个长度可变的数组对象，当存入的元素</p><p>超过数组长度时 ArrayList 会在内存中分配一个更大的数组来存储这些元素，因此<strong>可以将 ArrayList 集合看作一个长度灵活可变的数组</strong></p><p>它的大部分方法都是继承父类 <code>Collection</code> 和 <code>List</code> 接口的 其中 add () 方法 和 get () 分别实现元素的存入和取出</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">h</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">List</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(); <span class="comment">// 创建 ArrayList集合 相当于实现了List接口</span></span><br><span class="line">        List.add(<span class="number">3</span>);</span><br><span class="line">        List.add(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">        List.add(<span class="string">&quot;世界&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取集合中元素的个数  size()方法是 Collection的</span></span><br><span class="line">        System.out.println(<span class="string">&quot;集合的长度:&quot;</span>+List.size());</span><br><span class="line">        <span class="comment">// 取出并打印指定位置的元素 通过索引查找和数组一样从 0开始</span></span><br><span class="line">        <span class="comment">// 访问元素索引最好不要超过范围,否则会出现角标越界异常</span></span><br><span class="line">        System.out.println(<span class="string">&quot;第2个元素是:&quot;</span>+List.get(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------------------------------------------</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line"></span><br><span class="line">集合的长度:<span class="number">3</span></span><br><span class="line">第<span class="number">2</span>个元素是:你好</span><br><span class="line"></span><br></pre></td></tr></table></figure><p></p><p><img data-src="/2024/05/10/Collection%E5%8D%95%E5%88%97%E9%9B%86%E5%90%88ListSet/image_91_79mkk7c0YF.png" width></p><p><strong>注意 :</strong></p><p>由于 Aaytist 集合的底层使用一个数组来保存元素，在增加或删除指定位置的元素时，会创建新的数组，效率很低 因此不适合大量的增加删除操作，</p><p>因为这种数组的结构允许程序通过索引的方式来访问问元素，所以 ArrayList 集合查找元素很方法</p><h3 id="linkedlist实现类-增删-有序可重复"><a class="anchor" href="#linkedlist实现类-增删-有序可重复">#</a> LinkedList 实现类 增删 有序可重复</h3><p>LinkedList 集合内部维护了一个双向循环表，链表中的每一个元素都使用了引用的方式来记住它的前一个元素或后一个元素，从而可以将所有的元素彼此连接起来，<strong>LikedList 集合进行元素的增加删除操作时效率很高</strong>，</p><p><strong>常用方法</strong></p><p><img data-src="/2024/05/10/Collection%E5%8D%95%E5%88%97%E9%9B%86%E5%90%88ListSet/image_fhPTzsGO31.png"></p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">g</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LinkedList</span> <span class="variable">link</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>(); <span class="comment">// 创建了LinkeduList集合</span></span><br><span class="line">        link.add(<span class="number">3</span>);</span><br><span class="line">        link.add(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">        link.add(<span class="string">&quot;世界&quot;</span>);</span><br><span class="line">        System.out.println(link.toString()); <span class="comment">//取出并打印该集合的元素转换为字符串输出</span></span><br><span class="line">        System.out.println(link);  <span class="comment">// 同样取出元素直接输出对象</span></span><br><span class="line">        <span class="comment">// 上面两个的区别在于两个打印语句的结果是相同的，只是输出格式不同。</span></span><br><span class="line">        link.add(<span class="number">3</span>,<span class="string">&quot;saber&quot;</span>); <span class="comment">// 向该集合中指定位置插入元素</span></span><br><span class="line">        link.addFirst(<span class="string">&quot;插入&quot;</span>);     <span class="comment">// 向该集合第一个位置插入元素</span></span><br><span class="line">        System.out.println(link.getFirst()); <span class="comment">// 取出该集合中的第一个元素 插入</span></span><br><span class="line">        link.remove(<span class="number">2</span>); <span class="comment">// 删除该集合中指定位置的元素 按照数组索引来 所以是第三个 看清楚</span></span><br><span class="line">        System.out.println(<span class="string">&quot;会输出&quot;</span>+link);</span><br><span class="line">        link.removeFirst(); <span class="comment">// 删除该集合中的第一个元素</span></span><br><span class="line">        System.out.println(link);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">使用 LinkedList 对元素进行增加和删除操作是非常便捷的</span><br><span class="line"></span><br><span class="line">----------------------------------------------</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line"></span><br><span class="line">[<span class="number">3</span>, 你好, 世界]</span><br><span class="line">[<span class="number">3</span>, 你好, 世界]</span><br><span class="line">插入</span><br><span class="line">会输出 [插入, <span class="number">3</span>, 世界, saber]</span><br><span class="line">[<span class="number">3</span>, 世界, saber]</span><br></pre></td></tr></table></figure><p></p><h2 id="lterator接口-遍历迭代器"><a class="anchor" href="#lterator接口-遍历迭代器">#</a> lterator 接口 遍历迭代器</h2><p>接口 <code>Iterator</code> 接口也是集合中的一员，但是它与 Collection Map 有所不同，Collection 接口和 Map 接口主要是用于存储元素 而</p><p>Iteratore 主要用于迭代访问 (即遍历) <code>Collection</code> 中的元素，因此 Iteratior 对象也称迭代器</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">代码含义:</span><br><span class="line"></span><br><span class="line">hasNext()方法用于判断集合中是否还有下一个元素，如果有则返回<span class="literal">true</span>，否则返回<span class="literal">false</span>。如果返回<span class="literal">true</span>，</span><br><span class="line">则可以使用next()方法取出下一个元素，并将其赋值给一个Object类型的变量obj。最后，使用System.out.println()方法将obj打印出来。</span><br><span class="line">整个过程会一直重复，直到集合中的所有元素都被遍历完毕。因此，这段代码的作用是遍历ArrayList集合中的所有元素，并将它们打印出来。</span><br><span class="line"></span><br><span class="line"> 注意: </span><br><span class="line"></span><br><span class="line">通过next()方法获取元素时 必须保证获取元素的存在,否则会抛出 NoSuchElementException 异常  (无搜索元素异常)</span><br><span class="line"></span><br><span class="line">---------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">f</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list.add(<span class="string">&quot;张三&quot;</span>);  <span class="comment">// 存入了集合就必须使用 Object类型接收</span></span><br><span class="line">        list.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;赵六&quot;</span>); </span><br><span class="line">        <span class="comment">// 每一个集合迭代前都是必须通过下面的代码来获取迭代器</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> list.iterator(); <span class="comment">// 获取迭代器对象</span></span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())&#123;  <span class="comment">// 判断ArrayList集合 是否存在下一个元素</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> it.next(); <span class="comment">// 取出ArrayList集合中的元素 赋值给新的对象 obj</span></span><br><span class="line">            System.out.println(obj); <span class="comment">// 依次打印出全部的时间</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----------------------------------------------</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line"></span><br><span class="line">张三</span><br><span class="line">李四</span><br><span class="line">王五</span><br><span class="line">赵六</span><br></pre></td></tr></table></figure><p></p><h3 id="迭代判断删除"><a class="anchor" href="#迭代判断删除">#</a> 迭代判断删除</h3><p>使用迭代器对集合中的元素进行迭代时，如果调用了集合对象的 <code>remover()</code> 方法删除元素，那么继续使用迭代器会出现异常，下面通过案例来演示说明</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">e</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;赵六&quot;</span>);</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> list.iterator(); <span class="comment">// 获取迭代器对象</span></span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())&#123;  <span class="comment">// 判断ArrayList集合 是否存在下一个元素</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> it.next(); <span class="comment">// 取出ArrayList集合中的元素</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;张三&quot;</span>.equals(obj))</span><br><span class="line">            list.remove(obj); <span class="comment">// 删除后就也就不再继续</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list); <span class="comment">// 删除的是没有张三的集合</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p></p><p>上述代码会报出错误，原因是迭代器在运行期间删除了元素，导致迭代次数发生了变化，迭代结果不准确，解决方案</p><p><img data-src="/2024/05/10/Collection%E5%8D%95%E5%88%97%E9%9B%86%E5%90%88ListSet/image_xndague4OJ.png"></p><p>(1) 找到对应的名称字符删除后就使用 breack 语句跳出循环不再继续迭代，</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (it.hasNext())&#123;  <span class="comment">// 判断ArrayList集合 是否存在下一个元素</span></span><br><span class="line">         <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> it.next(); <span class="comment">// 取出ArrayList集合中的元素</span></span><br><span class="line">         <span class="keyword">if</span> (<span class="string">&quot;张三&quot;</span>.equals(obj))</span><br><span class="line">         list.remove(obj); <span class="comment">// 删除后就也就不再继续</span></span><br><span class="line">         <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p></p><p>(2) 使用迭代器本身的删除方法去进行删除，删除后所导致的迭代次数变化，对于迭代器本身是可预测的</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (it.hasNext())&#123;  <span class="comment">// 判断ArrayList集合 是否存在下一个元素</span></span><br><span class="line">          <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> it.next(); <span class="comment">// 取出ArrayList集合中的元素</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="string">&quot;张三&quot;</span>.equals(obj))</span><br><span class="line">          list.remove(); <span class="comment">// 删除后就也就不再继续</span></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="foreach-循环"><a class="anchor" href="#foreach-循环">#</a> foreach 循环</h3><p><code>Iterator</code> 虽然可以遍历集合中的元素，但是写法比较繁琐，简化书写提供了 <code>foreach</code> 循环，也称 增强 for 循环，它可以遍历数组或集合中的元素</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">语法格式:</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(容器中元素类型 临时变量: 容器变量)&#123;</span><br><span class="line">  执行语句</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">和<span class="keyword">for</span>循环相比foreach不再需要获得容器的长度,也不再需要根据索引访问,它会根据索引去访问容器的元素 </span><br><span class="line"> 并且自动遍历容器中的每个元素</span><br></pre></td></tr></table></figure><p></p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">foreach</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;赵六&quot;</span>);</span><br><span class="line">     <span class="keyword">for</span> (Object obj:list)&#123;<span class="comment">// 循环遍历ArrayList</span></span><br><span class="line">         System.out.println(obj); <span class="comment">// 取出</span></span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--------------------------------</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line"></span><br><span class="line">张三</span><br><span class="line">李四</span><br><span class="line">王五</span><br><span class="line">赵六</span><br><span class="line"></span><br></pre></td></tr></table></figure><p></p><h3 id="循环局限性"><a class="anchor" href="#循环局限性">#</a> 循环局限性</h3><p>当使用 foreach 循环遍历集合和数组时，只能访问集合中的元素，不能对其中的元素进行修改，下面是一个 <code>String</code> 类型的数组，演示 <code>foreach</code> 局限性</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">foreach</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> String[]  strrs = &#123;<span class="string">&quot;aaa&quot;</span>,<span class="string">&quot;ddd&quot;</span>,<span class="string">&quot;ccccc&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     <span class="comment">// foteach 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span>(String  str: strrs)&#123;</span><br><span class="line">            str=<span class="string">&quot;ddd&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;foreach循环修改后的数组&quot;</span>+strrs[<span class="number">0</span>]+<span class="string">&quot;,&quot;</span>+strrs[<span class="number">1</span>]+<span class="string">&quot;,&quot;</span>+strrs[<span class="number">2</span>]);</span><br><span class="line">        <span class="comment">// for循环遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i= <span class="number">0</span>;i&lt;strrs.length;i++)&#123;</span><br><span class="line">            strrs[i]=<span class="string">&quot;ddd&quot;</span>; <span class="comment">// 修改数据</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;循环修改后的数组&quot;</span>+strrs[<span class="number">0</span>]+<span class="string">&quot;,&quot;</span>+strrs[<span class="number">1</span>]+<span class="string">&quot;,&quot;</span>+strrs[<span class="number">2</span>]);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----------------------------------</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line"></span><br><span class="line">foreach循环修改后的数组aaa,ddd,ccccc</span><br><span class="line">循环修改后的数组ddd,ddd,ddd</span><br><span class="line"></span><br></pre></td></tr></table></figure><p></p><p>foreach 循环 <code>str=“ddd”</code> 只是将临时的变量指向一个新的字符串并不能修改元素，for 循环则是可以通过索引的方式对数组中的元素进行修改的</p><h2 id="set接口"><a class="anchor" href="#set接口">#</a> Set 接口</h2><p>Set 接口和 List 接口一样，同样继承 <code>Collection</code> 接口，方法和他基本一致，功能上并没有扩充，反而更加严格，它的 List 接口不同在于，<strong>Set 接口元素无序且不重复</strong></p><p>实现类</p><ul><li>**HashSet **： 根据对象的散列值来确定元素在集合中存储的位置，具有良好的存取和查找功能</li><li><strong>TreeSet</strong> ： 以二叉树方式存储元素，它可以实现对元素的排序</li></ul><h3 id="hashset-实现类无序无重复"><a class="anchor" href="#hashset-实现类无序无重复">#</a> HashSet 实现类无序无重复</h3><p>存储元素不可重复 意味着没有相同的，并且元素无序</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">foreach</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> String[]  strrs = &#123;<span class="string">&quot;aaa&quot;</span>,<span class="string">&quot;ddd&quot;</span>,<span class="string">&quot;ccccc&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HashSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>(); <span class="comment">// 创建HashSet集合</span></span><br><span class="line">        set.add(<span class="string">&quot;张三&quot;</span>); <span class="comment">//  向集合中添加元素</span></span><br><span class="line">        set.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;王五&quot;</span>); <span class="comment">// 添加重复元素</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> set.iterator(); <span class="comment">// 获取迭代器接口</span></span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())&#123; <span class="comment">// while 判断集合是否有元素</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> it.next(); <span class="comment">// 如果有元素则通过迭代器 next() 获取元素</span></span><br><span class="line">            System.out.println(obj); <span class="comment">// 打印获取到的元素</span></span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line"></span><br><span class="line">李四</span><br><span class="line">张三</span><br><span class="line">王五</span><br><span class="line"></span><br></pre></td></tr></table></figure><p></p><p><strong>注意:</strong></p><p>取出元素和添加元素并不一致，并且重复添加的元素只出现了一次，它之所以可以确保不出现重复的元素，做了很多工作，add 添加元素时，首先调用存入对象的 <code>hashCode()</code> 方法获得对象的散列值，然后根据元素的散列值计算出特有的存储位置 **, 散列值还是看数据类型是否相等的 **, 只要数据类型相等，里面数字相等那么就是一样的，如果出现 <code>String</code> 字符串的 100 和 <code>int</code> 类型的 100 其实是不同的，因为数据类型不同，并且 <code>equals</code> <strong>使用的前提也是相同数据类型比较字符串类型一致</strong>，详见<span class="exturl" data-url="aHR0cHM6Ly93d3cud29sYWkuY29tLzJpOUVnNXBxZTNxODF0RkJkeFZmVTk="> String 字符串 Random 数字运算</span>、</p><p>上面是不相同的情况，相同情况则是计算哈希后，进行 <code>equals</code> 比较，如果比较存在，则是舍弃 没有则是加入</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">foreach</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> String[]  strrs = &#123;<span class="string">&quot;aaa&quot;</span>,<span class="string">&quot;ddd&quot;</span>,<span class="string">&quot;ccccc&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HashSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>(); <span class="comment">// 创建HashSet集合</span></span><br><span class="line">        set.add(<span class="string">&quot;张三&quot;</span>); <span class="comment">//  向集合中添加元素</span></span><br><span class="line">        set.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;王五&quot;</span>); <span class="comment">// 添加重复元素</span></span><br><span class="line">        set.add(<span class="string">&quot;100&quot;</span>);  <span class="comment">// 两个类型不同</span></span><br><span class="line">        set.add(<span class="number">100</span>); <span class="comment">// 两个类型不同</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> set.iterator(); <span class="comment">// 获取迭代器接口</span></span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())&#123; <span class="comment">// while 判断集合是否有元素</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> it.next(); <span class="comment">// 如果有元素则通过迭代器 next() 获取元素</span></span><br><span class="line">            System.out.println(obj); <span class="comment">// 打印获取到的元素</span></span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------------------------------</span><br><span class="line"></span><br><span class="line">两个内容相同类型不同,散列值也是不同 会保存下来</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line"></span><br><span class="line">李四</span><br><span class="line"><span class="number">100</span></span><br><span class="line">张三</span><br><span class="line"><span class="number">100</span></span><br><span class="line">王五</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p></p><h3 id="hashset-存储class类"><a class="anchor" href="#hashset-存储class类">#</a> HashSet 存储 Class 类</h3><p>将字符串存入 <code>HshSet</code> 时 String 类已经重写了 <code>hashCode</code> 和 <code>equals</code> 方法，下面演示存储自定义的 <code>Class</code> 类 的结果</p><p><strong>未改写 hashCode 和 equals () 方法</strong></p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">Student</span>&#123;</span><br><span class="line">    String id;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String id, String name)</span> &#123; <span class="comment">// 创建构造方法</span></span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  id+<span class="string">&quot;:&quot;</span>+name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">foreach</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> String[]  strrs = &#123;<span class="string">&quot;aaa&quot;</span>,<span class="string">&quot;ddd&quot;</span>,<span class="string">&quot;ccccc&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HashSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>(); <span class="comment">// 创建HashSet集合</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;杜甫&quot;</span>);  <span class="comment">// 创建对象传入参数到构造函数中</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;2&quot;</span>,<span class="string">&quot;李白&quot;</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;2&quot;</span>,<span class="string">&quot;李白&quot;</span>);</span><br><span class="line">        set.add(stu1); <span class="comment">// 将对象的值传入到集合中 也就是传入 class</span></span><br><span class="line">        set.add(stu2);</span><br><span class="line">        set.add(stu3);</span><br><span class="line">        System.out.println(set);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------------------------------------------</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>:李白, <span class="number">2</span>:李白, <span class="number">1</span>:杜甫]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 注意: </span><br><span class="line"></span><br><span class="line">在Java中，当我们使用System.out.println()方法输出一个对象时，实际上会自动调用该对象的 toString ()方</span><br><span class="line">法来获取其字符串表示形式。因此，在这段代码中，当我们使用System.out.println(set)输出HashSet对象时</span><br><span class="line">实际上会自动调用每个Student对象的toString()方法来获取其字符串表示形式，并将它们拼接成一个字符串输</span><br><span class="line">出。虽然你没有显式调用toString()方法，但它确实被隐式调用了。 所以上面代码我们没有调用实际上啊是自动</span><br><span class="line">调用了</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------</span><br><span class="line"></span><br><span class="line">运行结果出现了两个相同的李白<span class="number">2</span>,本来应该被认为是重复元素,不允许输出的,为什么没有去掉是因为在定义</span><br><span class="line">Class类时 没有重写hashCode和equals()方法</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p></p><p><strong>已改写 hashCode 和 equals () 方法</strong></p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">import</span> java.util.HashSet;</span><br><span class="line">     <span class="keyword">class</span>  <span class="title class_">Student</span>&#123;</span><br><span class="line">     String id;</span><br><span class="line">     String name;</span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String id, String name)</span> &#123; <span class="comment">// 创建构造方法</span></span><br><span class="line">     <span class="built_in">this</span>.id = id;</span><br><span class="line">     <span class="built_in">this</span>.name = name;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;  <span class="comment">// 重写toSring() 方法</span></span><br><span class="line">      <span class="keyword">return</span>  id+<span class="string">&quot;:&quot;</span>+name;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>&#123;  <span class="comment">// 重写了hashCode()</span></span><br><span class="line">            <span class="keyword">return</span>  id.hashCode();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重写 eqlals 方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>==obj)&#123;  <span class="comment">// 判断是否是同一个对象</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 是的话就是真</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!(obj <span class="keyword">instanceof</span>  Student))&#123; <span class="comment">// 判断对象是否是Student类型</span></span><br><span class="line">                <span class="keyword">return</span>  <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Student</span>  <span class="variable">stu</span> <span class="operator">=</span> (Student) obj; <span class="comment">// 将对象强制转换为 Student 类型</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> <span class="built_in">this</span>.id.equals(stu.id); <span class="comment">// 判断id值是否相同</span></span><br><span class="line">            <span class="keyword">return</span>  b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">foreach</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> String[]  strrs = &#123;<span class="string">&quot;aaa&quot;</span>,<span class="string">&quot;ddd&quot;</span>,<span class="string">&quot;ccccc&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">            <span class="type">HashSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>(); <span class="comment">// 创建HashSet集合</span></span><br><span class="line">            <span class="type">Student</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;杜甫&quot;</span>);  <span class="comment">// 创建对象传入参数到构造函数中</span></span><br><span class="line">            <span class="type">Student</span> <span class="variable">stu2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;2&quot;</span>,<span class="string">&quot;李白&quot;</span>);</span><br><span class="line">            <span class="type">Student</span> <span class="variable">stu3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;2&quot;</span>,<span class="string">&quot;李白&quot;</span>);</span><br><span class="line">            set.add(stu1); <span class="comment">// 将对象的值传入到集合中</span></span><br><span class="line">            set.add(stu2);</span><br><span class="line">            set.add(stu3);</span><br><span class="line">            System.out.println(set);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">----------------------------------------</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>:杜甫, <span class="number">2</span>:李白]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 注意: </span><br><span class="line"></span><br><span class="line">Student类重写了Object类的hashCode()返回 id 属性的散列值还有 equals  并且在 equals  方法比较对象</span><br><span class="line">的id属性值是否相等并返回结果 HashSet 集合添加元素时,因为改写了 hashCode 方法所以 add 添加时</span><br><span class="line">会进行比较发现散列值相同而且 stue.equsls(stu3)  返回<span class="literal">true</span> 集合认为两个参数相等因为重复的被去掉了</span><br></pre></td></tr></table></figure><p></p><h3 id="linkedhashset实现类存取有序无重复"><a class="anchor" href="#linkedhashset实现类存取有序无重复">#</a> LinkedHashSet 实现类存取有序无重复</h3><p><code>HashSet</code> 集合存储的元素是无序的，如果想让元素存取顺序一致，那么就使用 <code>LinkedHashSet</code></p><p>它是 <code>HashSet</code> 的子类，它和 <code>LinkdList</code> 一样 使用双向链表来维护内部元素关系</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">foreach</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">            <span class="type">LinkedHashSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>();</span><br><span class="line">            set.add(<span class="string">&quot;张三&quot;</span>); <span class="comment">// 集合添加元素</span></span><br><span class="line">            set.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">            set.add(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">            set.add(<span class="string">&quot;王五&quot;</span>); <span class="comment">// 即使出现重复元素 也还是会显示一个</span></span><br><span class="line">            <span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> set.iterator(); <span class="comment">// 迭代器判断</span></span><br><span class="line">            <span class="keyword">while</span> (it.hasNext())&#123; <span class="comment">// 循环判断是否有元素</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> it.next();</span><br><span class="line">                System.out.println(obj);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">-------------------------------------------------</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line"></span><br><span class="line">张三</span><br><span class="line">李四</span><br><span class="line">王五</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p></p><h3 id="treeset-实现类有序无重复"><a class="anchor" href="#treeset-实现类有序无重复">#</a> TreeSet 实现类有序无重复</h3><p>为了对集合的元素进行排序， <code>Set</code> 接口提供了另一个可以对 HashSet 集合中元素排序的类 —— <code>TreeSet</code></p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">foreach</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">            <span class="type">TreeSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>();</span><br><span class="line">            set.add(<span class="number">1</span>);</span><br><span class="line">            set.add(<span class="number">1</span>);</span><br><span class="line">            set.add(<span class="number">3</span>);</span><br><span class="line">            set.add(<span class="number">5</span>);</span><br><span class="line">            set.add(<span class="number">6</span>);</span><br><span class="line">            System.out.println(set);</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------------------------------------------</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">元素会自动排序并且没有存在重复</span><br><span class="line"></span><br><span class="line">TreeSet 集合之所以可以对添加元素排序,是因为元素的类实现了 Comparable 接口 </span><br><span class="line">(基本类型的包装类 String类都实现了该接口)  Comparable 强行对实现它的每个类的对象进行整体排序</span><br><span class="line"> 这种排序被称为自然排序Comparable接口的compareTo()方法被称为自然比较方法！</span><br></pre></td></tr></table></figure><p></p><p><strong>什么是 comparTo () 方法</strong></p><ul><li></li></ul><p>Comparable 接口是 Java 中的一个接口，用于实现对象之间的比较。其中，compareTo () 方法是 Comparable 接口中的一个方法，用于比较当前对象与另一个对象的大小关系。</p><p>compareTo () 方法的返回值为 int 类型，表示当前对象与另一个对象的大小关系。如果当前对象小于另一个对象，则返回负整数；如果当前对象等于另一个对象，则返回 0；如果当前对象大于另一个对象，则返回正整数。</p><p>compareTo () 方法的作用是用于实现对象之间的排序。在 Java 中，如果一个类实现了 Comparable 接口，就可以使用 Collections.sort () 方法或 Arrays.sort () 方法对该类的对象进行排序。在排序过程中，会调用 compareTo () 方法来比较对象之间的大小关系，从而实现排序。</p><p>需要注意的是，如果一个类实现了 Comparable 接口，就必须实现 compareTo () 方法，否则会编译错误。另外，compareTo () 方法的实现应该满足一定的规则，例如具有传递性、反对称性等，否则可能会导致排序结果不正确</p><h4 id="treeset-存储class类"><a class="anchor" href="#treeset-存储class类">#</a> TreeSet 存储 Class 类</h4><p>如果同 <code>HashSet()</code> 一样存储<strong> Class</strong> 类，TreeSet 集合不会去进行排序，Class 类对象必须实现 <code>Comparable</code></p><p>接口并重写 <code>compareTo</code> 方法实现对象元素的顺序存取 <strong>想对添加的元素进行排序就先重写</strong></p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义Student类   第一步实现了Comparable泛型; </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重写toString字符串方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id+<span class="string">&quot;:&quot;</span>+name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//   第二步重写 compareTo方法 </span></span><br><span class="line">    <span class="comment">//  三种compareTo方法的三种情况 </span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student o)</span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span> ;   <span class="comment">// 集合中只有一个元素 还是第一个张三</span></span><br><span class="line">        <span class="comment">// return  1  // 集合怎么存怎么取的顺序</span></span><br><span class="line"><span class="comment">//        return -1;   // 集合按照存入的元素进行倒序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">foreach</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">            <span class="type">TreeSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>();</span><br><span class="line">            set.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;张三&quot;</span>)); <span class="comment">// 直接打印省去了 stu1 stu2 操作</span></span><br><span class="line">            set.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;2&quot;</span>,<span class="string">&quot;李白&quot;</span>));</span><br><span class="line">            set.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;3&quot;</span>,<span class="string">&quot;毒品&quot;</span>));</span><br><span class="line">            System.out.println(set);</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------------------------------------------</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>  </span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>:张三]</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span> </span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>:张三, <span class="number">2</span>:李白, <span class="number">3</span>:毒品]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">[<span class="number">3</span>:毒品, <span class="number">2</span>:李白, <span class="number">1</span>:张三]</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p></p><p>除了自然排序还有另一种排序方法；即实现 <code>Comparator</code> 接口 重写 <code>compare()</code> 方法 <code>equals()</code> 方法</p><p>但是由于所有的类默认继承 Object 而 Object 又存在 <code>equals()</code> 所以自定义比较器类时，不用重写 <code>equals</code> 方法，只需要重写 <code>compare()</code> 方法这种排序称为<strong>比较器排序</strong></p><p>通过自定义 <code>Class</code> 类对象 通过<strong>比较器</strong>存入 <code>TreeSet</code> 集合</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重写toString字符串方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id+<span class="string">&quot;:&quot;</span>+name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">foreach</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 声明了一个TreeSet集合并通过匿名内部类的方式实现了Comparator接口，</span></span><br><span class="line">            <span class="type">TreeSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>(<span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 然后重写了compare()方法并</span></span><br><span class="line">                <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            set.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;张三&quot;</span>)); <span class="comment">// 直接打印省去了 stu1 stu2 操作</span></span><br><span class="line">            set.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;2&quot;</span>,<span class="string">&quot;李白&quot;</span>));</span><br><span class="line">            set.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;3&quot;</span>,<span class="string">&quot;毒品&quot;</span>));</span><br><span class="line">            System.out.println(set);</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--------------------------------------------</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line"></span><br><span class="line">[<span class="number">3</span>:毒品, <span class="number">2</span>:李白, <span class="number">1</span>:张三]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p></p></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2024-11-20 20:57:40" itemprop="dateModified" datetime="2024-11-20T20:57:40+08:00">2024-11-20</time> </span><span id="2024/05/10/Collection单列集合ListSet/" class="item leancloud_visitors" data-flag-title="Collection单列集合ListSet" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>月 <i class="ic i-at"><em>@</em></i>月</li><li class="link"><strong>本文链接：</strong> <a href="https://lunargod.github.io/2024/05/10/Collection%E5%8D%95%E5%88%97%E9%9B%86%E5%90%88ListSet/" title="Collection单列集合ListSet">https://lunargod.github.io/2024/05/10/Collection单列集合ListSet/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC96aC1DTg=="><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2024/05/10/Map%E5%8F%8C%E5%88%97%E9%9B%86%E5%90%88%E6%A0%B9%E6%8E%A5%E5%8F%A3HashMap_TreeMap/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;pic.imgdb.cn&#x2F;item&#x2F;67407294d29ded1a8cf57656.png" title="Map双列集合根接口HashMap_TreeMap"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> Java</span><h3>Map双列集合根接口HashMap_TreeMap</h3></a></div><div class="item right"><a href="/2024/05/13/%E6%B3%9B%E5%9E%8BLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;pic.imgdb.cn&#x2F;item&#x2F;67371c20d29ded1a8c8b60e8.jpg" title="泛型 Lambda 表达式"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> Java</span><h3>泛型 Lambda 表达式</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">集合概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#collection-%E5%8D%95%E5%88%97%E9%9B%86%E5%90%88%E6%A0%B9%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.</span> <span class="toc-text">Collection 单列集合根接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#list%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.</span> <span class="toc-text">List 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#arraylist%E5%AE%9E%E7%8E%B0%E7%B1%BB-%E6%9F%A5%E8%AF%A2-%E6%9C%89%E5%BA%8F%E5%8F%AF%E9%87%8D%E5%A4%8D"><span class="toc-number">3.1.</span> <span class="toc-text">ArrayList 实现类 查询 有序可重复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#linkedlist%E5%AE%9E%E7%8E%B0%E7%B1%BB-%E5%A2%9E%E5%88%A0-%E6%9C%89%E5%BA%8F%E5%8F%AF%E9%87%8D%E5%A4%8D"><span class="toc-number">3.2.</span> <span class="toc-text">LinkedList 实现类 增删 有序可重复</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lterator%E6%8E%A5%E5%8F%A3-%E9%81%8D%E5%8E%86%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">4.</span> <span class="toc-text">lterator 接口 遍历迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%88%A4%E6%96%AD%E5%88%A0%E9%99%A4"><span class="toc-number">4.1.</span> <span class="toc-text">迭代判断删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#foreach-%E5%BE%AA%E7%8E%AF"><span class="toc-number">4.2.</span> <span class="toc-text">foreach 循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-number">4.3.</span> <span class="toc-text">循环局限性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#set%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.</span> <span class="toc-text">Set 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#hashset-%E5%AE%9E%E7%8E%B0%E7%B1%BB%E6%97%A0%E5%BA%8F%E6%97%A0%E9%87%8D%E5%A4%8D"><span class="toc-number">5.1.</span> <span class="toc-text">HashSet 实现类无序无重复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashset-%E5%AD%98%E5%82%A8class%E7%B1%BB"><span class="toc-number">5.2.</span> <span class="toc-text">HashSet 存储 Class 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#linkedhashset%E5%AE%9E%E7%8E%B0%E7%B1%BB%E5%AD%98%E5%8F%96%E6%9C%89%E5%BA%8F%E6%97%A0%E9%87%8D%E5%A4%8D"><span class="toc-number">5.3.</span> <span class="toc-text">LinkedHashSet 实现类存取有序无重复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#treeset-%E5%AE%9E%E7%8E%B0%E7%B1%BB%E6%9C%89%E5%BA%8F%E6%97%A0%E9%87%8D%E5%A4%8D"><span class="toc-number">5.4.</span> <span class="toc-text">TreeSet 实现类有序无重复</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#treeset-%E5%AD%98%E5%82%A8class%E7%B1%BB"><span class="toc-number">5.4.1.</span> <span class="toc-text">TreeSet 存储 Class 类</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2023/02/13/Java%E5%9F%BA%E7%A1%80/" rel="bookmark" title="Java前置基础">Java前置基础</a></li><li><a href="/2023/03/31/%E5%8F%8D%E5%B0%84/" rel="bookmark" title="Java--反射机制">Java--反射机制</a></li><li><a href="/2023/05/01/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" rel="bookmark" title="Java--反序列化">Java--反序列化</a></li><li><a href="/2023/05/01/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="bookmark" title="Java--多线程">Java--多线程</a></li><li><a href="/2024/01/18/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/" rel="bookmark" title="I - O (输入-输出) 字节流 字符流 缓冲流">I - O (输入-输出) 字节流 字符流 缓冲流</a></li><li><a href="/2024/04/01/%E5%B0%81%E8%A3%85%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81/" rel="bookmark" title="面向对象-封装继承多态">面向对象-封装继承多态</a></li><li><a href="/2024/04/12/%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81%E6%8A%BD%E8%B1%A1/" rel="bookmark" title="继承 super 抽象 接口 多态">继承 super 抽象 接口 多态</a></li><li><a href="/2024/04/30/Object%E5%86%85%E9%83%A8%E7%B1%BB%E5%BC%82%E5%B8%B8/" rel="bookmark" title="Objbect  内部类异常">Objbect 内部类异常</a></li><li><a href="/2024/05/03/%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E7%B1%BB%E5%8C%85%E8%A3%85%E7%B1%BB/" rel="bookmark" title="日期时间类 包装类">日期时间类 包装类</a></li><li class="active"><a href="/2024/05/10/Collection%E5%8D%95%E5%88%97%E9%9B%86%E5%90%88ListSet/" rel="bookmark" title="Collection单列集合ListSet">Collection单列集合ListSet</a></li><li><a href="/2024/05/10/Map%E5%8F%8C%E5%88%97%E9%9B%86%E5%90%88%E6%A0%B9%E6%8E%A5%E5%8F%A3HashMap_TreeMap/" rel="bookmark" title="Map双列集合根接口HashMap_TreeMap">Map双列集合根接口HashMap_TreeMap</a></li><li><a href="/2024/05/13/%E6%B3%9B%E5%9E%8BLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/" rel="bookmark" title="泛型 Lambda 表达式">泛型 Lambda 表达式</a></li><li><a href="/2024/05/14/Jdbc%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="bookmark" title="Jdbc数据库">Jdbc数据库</a></li><li><a href="/2024/05/21/String%E5%AD%97%E7%AC%A6%E4%B8%B2Random%E6%95%B0%E5%AD%97%E8%BF%90%E7%AE%97/" rel="bookmark" title="String字符串 Random数字运算">String字符串 Random数字运算</a></li><li><a href="/2024/06/30/JSP%E8%AF%AD%E6%B3%95/" rel="bookmark" title="JSP语法">JSP语法</a></li><li><a href="/2024/07/10/JavaBean/" rel="bookmark" title="JavaBean">JavaBean</a></li><li><a href="/2024/07/20/MyBatis%E9%85%8D%E7%BD%AE/" rel="bookmark" title="MyBatis配置">MyBatis配置</a></li><li><a href="/2024/08/20/JavaServlet/" rel="bookmark" title="JavaServlet">JavaServlet</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="月" data-src="/images/avatar.jpg"><p class="name" itemprop="name">月</p><div class="description" itemprop="description">你越安静 你听到的就越多</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">45</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">7</span> <span class="name">分类</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0x1bmFSR29k" title="https:&#x2F;&#x2F;github.com&#x2F;LunaRGod"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly94LmNvbS95dWVzZTEwMjkxMDQ1Mw==" title="https:&#x2F;&#x2F;x.com&#x2F;yuese102910453"><i class="ic i-twitter"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9mZW5nLWppYW4tNDgtNjc=" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;feng-jian-48-67"><i class="ic i-zhihu"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTE2NjY5MDk3ODQ=" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;1666909784"><i class="ic i-cloud-music"></i></span> <span class="exturl item email" data-url="bWFpbHRvOnNhYmVyMGRheUBxcS5jb20=" title="mailto:saber0day@qq.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2024/05/10/Map%E5%8F%8C%E5%88%97%E9%9B%86%E5%90%88%E6%A0%B9%E6%8E%A5%E5%8F%A3HashMap_TreeMap/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2024/05/13/%E6%B3%9B%E5%9E%8BLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/Java/" title="分类于 Java">Java</a></div><span><a href="/2023/02/13/Java%E5%9F%BA%E7%A1%80/" title="Java前置基础">Java前置基础</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%86%85%E7%BD%91%E6%94%BB%E9%98%B2/" title="分类于 内网攻防">内网攻防</a></div><span><a href="/2024/08/29/%E5%9C%9F%E8%B1%86%E5%AE%B6%E6%97%8F/" title="土豆家族提权">土豆家族提权</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/" title="分类于 漏洞复现">漏洞复现</a></div><span><a href="/2024/07/01/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/" title="Redis未授权访问+工具复现">Redis未授权访问+工具复现</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Java/" title="分类于 Java">Java</a></div><span><a href="/2023/05/01/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="Java--多线程">Java--多线程</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%86%85%E7%BD%91%E6%94%BB%E9%98%B2/" title="分类于 内网攻防">内网攻防</a></div><span><a href="/2024/09/19/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%A9%E7%94%A8/" title="横向移动利用总结">横向移动利用总结</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Java/" title="分类于 Java">Java</a></div><span><a href="/2024/07/10/JavaBean/" title="JavaBean">JavaBean</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%86%85%E7%BD%91%E9%9A%A7%E9%81%93%E4%BB%A3%E7%90%86/" title="分类于 内网隧道代理">内网隧道代理</a></div><span><a href="/2024/05/01/%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/" title="隧道技术&amp; DNS&#x2F;SSH Linux反向上线">隧道技术& DNS/SSH Linux反向上线</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/" title="分类于 漏洞复现">漏洞复现</a></div><span><a href="/2023/03/29/Strust2/" title="S2-001 RCE">S2-001 RCE</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E6%B8%97%E9%80%8F%E9%9D%B6%E5%9C%BAWP/" title="分类于 渗透靶场WP">渗透靶场WP</a></div><span><a href="/2024/07/18/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8%E4%BA%8C/" title="红日安全vulnstack (二)">红日安全vulnstack (二)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%86%85%E7%BD%91%E6%94%BB%E9%98%B2/" title="分类于 内网攻防">内网攻防</a></div><span><a href="/2024/06/09/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/" title="非约束委派 非约束委派 靶场">非约束委派 非约束委派 靶场</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2023 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">月 @ LunaRGFod</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">348k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">5:16</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2024/05/10/Collection单列集合ListSet/",favicon:{show:"Monthlblog",hide:"Monthlyblog"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(t){return t.includes("#")},function(t){return new RegExp(LOCAL.path+"$").test(t)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>